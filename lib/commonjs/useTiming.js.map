{"version":3,"sources":["useTiming.ts"],"names":["interpolate","interpolateV1","interpolateNode","interpolateV2","require","Easing","EasingV1","EasingNode","EasingV2","useTiming","animatedStaticIndex","animatedOverrideIndex","value","velocity","state","size","screenWidth","clock","isManuallyAnimated","config","toValue","Animated","Value","duration","easing","out","exp","animationState","finished","position","frameTime","time","valueClamp","inputRange","outputRange","I18nManager","isRTL","extrapolate","Extrapolate","CLAMP","velocityClamp","isTimingInterrupted","State","BEGAN","finishTiming","UNDETERMINED","shouldAnimate","shouldReset","shouldAnimateNext","animatedPosition","ACTIVE","END"],"mappings":"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","sourcesContent":["import Animated, {\n  sub,\n  add,\n  or,\n  block,\n  cond,\n  eq,\n  set,\n  stopClock,\n  and,\n  not,\n  clockRunning,\n  startClock,\n  lessThan,\n  greaterThan,\n  abs,\n  timing,\n  onChange,\n} from 'react-native-reanimated';\nimport { I18nManager } from 'react-native';\nimport { State } from 'react-native-gesture-handler';\nimport { useClock, useValue } from 'react-native-redash';\nimport { useMemo } from 'react';\n\nconst {\n  interpolate: interpolateV1,\n  interpolateNode: interpolateV2,\n} = require('react-native-reanimated');\nconst interpolate = interpolateV2 || interpolateV1;\n\nconst {\n  Easing: EasingV1,\n  EasingNode: EasingV2,\n} = require('react-native-reanimated');\nconst Easing = EasingV2 || EasingV1;\n\ninterface useTimingProps {\n  value: Animated.Adaptable<number>;\n  animatedStaticIndex: Animated.Value<number>;\n  animatedOverrideIndex: Animated.Value<number>;\n  velocity: Animated.Adaptable<number>;\n  state: Animated.Value<State>;\n  offset?: Animated.Value<number>;\n  deceleration?: number;\n  size: number;\n  screenWidth: number;\n}\n\nexport const useTiming = ({\n  animatedStaticIndex,\n  animatedOverrideIndex,\n  value,\n  velocity,\n  state,\n  size,\n  screenWidth,\n}: useTimingProps) => {\n  const clock = useClock();\n  const isManuallyAnimated = useValue(0);\n\n  const config = useMemo(\n    () => ({\n      toValue: new Animated.Value(0),\n      duration: 500,\n      easing: Easing.out(Easing.exp),\n    }),\n    []\n  );\n\n  const animationState = useMemo(\n    () => ({\n      finished: new Animated.Value(0),\n      position: new Animated.Value(0),\n      frameTime: new Animated.Value(0),\n      time: new Animated.Value(0),\n    }),\n    []\n  );\n\n  const valueClamp = useMemo(\n    () =>\n      interpolate(value, {\n        inputRange: [screenWidth * -1, 0, screenWidth],\n        outputRange: I18nManager.isRTL ? [-1, 0, 1] : [1, 0, -1],\n        extrapolate: Animated.Extrapolate.CLAMP,\n      }),\n    [value, screenWidth]\n  );\n\n  const velocityClamp = useMemo(\n    () =>\n      interpolate(velocity, {\n        inputRange: [screenWidth * -2, 0, screenWidth * 2],\n        outputRange: I18nManager.isRTL ? [-0.5, 0, 0.5] : [0.5, 0, -0.5],\n        extrapolate: Animated.Extrapolate.CLAMP,\n      }),\n    [screenWidth, velocity]\n  );\n\n  const isTimingInterrupted = and(eq(state, State.BEGAN), clockRunning(clock));\n  const finishTiming = useMemo(\n    () => [\n      set(animatedStaticIndex, config.toValue),\n      set(animatedOverrideIndex, config.toValue),\n      set(animationState.frameTime, 0),\n      set(animationState.time, 0),\n      set(state, State.UNDETERMINED),\n      set(isManuallyAnimated, 0),\n      stopClock(clock),\n    ],\n    [\n      state,\n      animatedOverrideIndex,\n      animatedStaticIndex,\n      animationState.frameTime,\n      animationState.time,\n      clock,\n      config.toValue,\n      isManuallyAnimated,\n    ]\n  );\n\n  const shouldAnimate = useMemo(\n    () =>\n      and(\n        not(and(eq(animatedStaticIndex, 0), lessThan(valueClamp, 0))),\n        not(and(eq(animatedStaticIndex, size - 1), greaterThan(valueClamp, 0)))\n      ),\n    [animatedStaticIndex, size, valueClamp]\n  );\n  const shouldReset = useMemo(\n    () => not(greaterThan(add(abs(valueClamp), abs(velocityClamp)), 0.5)),\n    [valueClamp, velocityClamp]\n  );\n  const shouldAnimateNext = useMemo(\n    () =>\n      greaterThan(\n        add(animationState.position, velocityClamp),\n        animatedStaticIndex\n      ),\n    [animatedStaticIndex, animationState.position, velocityClamp]\n  );\n\n  const animatedPosition = useMemo(\n    () =>\n      block([\n        cond(isTimingInterrupted, finishTiming),\n        cond(\n          eq(state, State.ACTIVE),\n          cond(\n            and(\n              not(and(eq(animatedStaticIndex, 0), lessThan(valueClamp, 0))),\n              not(\n                and(\n                  eq(animatedStaticIndex, size - 1),\n                  greaterThan(valueClamp, 0)\n                )\n              )\n            ),\n            [\n              set(animationState.finished, 0),\n              set(isManuallyAnimated, 0),\n              set(\n                animationState.position,\n                add(animatedStaticIndex, valueClamp)\n              ),\n            ]\n          )\n        ),\n\n        onChange(animatedOverrideIndex, [\n          set(isManuallyAnimated, 1),\n          set(animationState.finished, 0),\n        ]),\n\n        cond(or(eq(state, State.END), isManuallyAnimated), [\n          cond(and(not(clockRunning(clock)), not(animationState.finished)), [\n            cond(\n              isManuallyAnimated,\n              set(config.toValue, animatedOverrideIndex),\n              cond(\n                or(shouldReset, not(shouldAnimate)),\n                set(config.toValue, animatedStaticIndex),\n                cond(\n                  shouldAnimateNext,\n                  set(config.toValue, add(animatedStaticIndex, 1)),\n                  set(config.toValue, sub(animatedStaticIndex, 1))\n                )\n              )\n            ),\n            set(animationState.finished, 0),\n            set(animationState.frameTime, 0),\n            set(animationState.time, 0),\n            startClock(clock),\n          ]),\n          timing(clock, animationState, config),\n          cond(animationState.finished, finishTiming),\n        ]),\n\n        animationState.position,\n      ]),\n    [\n      size,\n      state,\n      animatedOverrideIndex,\n      animatedStaticIndex,\n      animationState,\n      clock,\n      config,\n      finishTiming,\n      isManuallyAnimated,\n      isTimingInterrupted,\n      shouldAnimate,\n      shouldAnimateNext,\n      shouldReset,\n      valueClamp,\n    ]\n  );\n  return animatedPosition;\n};\n"]}